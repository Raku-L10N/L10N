{
    ENTRADA diga "hello";
    SAIDA diga "goodbye"
}
sub answer retorna Int é raw {
    42
}
meu classe Frobnicate {
    tem $.a = 666;
    submethod TWEAK {
        $!a = 42
    }
    multi método foo {
        diga si-mesmo.a
    }
}
diga Frobnicate.new.foo;
meu $a = 41;
meu $b quando * >= 666 = 666;
diga $b R/ $a;
diga 42 (elem) 1 .. 100;
se $a {
    $a++
}
se-não-se $b {
    morra "That is not the right number!"
}
se-não {
    nota "Shouldn't see this"
}
diga "incremented" se $a == answer;
com $a {
    diga $a
}
ou-com $b {
    avise "still not the right number"
}
dado 666 {
    quando 42 {
        diga "the answer"
    }
    predefinita {
        tranquilamente avise "No answer"
    }
}
não strict;
$c = 137;
dd $c.indente(4);
usa strict;
meu @a = ^10;
diga @a.primo(* %% 2, :end);
meu %h = a => 666;
diga %h<a>:delete;
put qq:to/HERE/;
heredoc
HERE
por ^3 {
    .diga
}
.diga por <a b c>;
ciclo {
    diga "loop";
    último
}
meu enum KNOBS <left right up down>;
diga down;
meu subset FOO do Int quando * > 666;
meu FOO $foo = 1000;
diga $foo
